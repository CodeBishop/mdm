#!/usr/bin/env python2

# Multi-Drive Manager (mdm)
###########################
# A utility for managing the simultaneous S.M.A.R.T. testing and secure wiping of multiple data storage devices.
# NOTE: Beep effects won't work unless you have 'beep' installed and the pcspkr module installed (either
#       temporarily by modprobe or permanently in /etc/modules).


# Misc Dev Notes
################
# Summary of sysrescue display differences.
#   The terminal does not get restored when a curses program ends. The prompt re-appears at the bottom
#       and the screen remains cluttered with whatever was on display.
#   Only 8 colors are available and the curses.COLORS constant reflects that fact.
#   Font effects: dim=underline=normal, reverse=standout(fg/bg color reversal), bold is brighter text.
#       blink is grey text on dark grey background (no blinking).
#   Characters known to appear in smartctl output:
#       Parantheses, numbers, letters, underscores, whitespace, +, -, :, =, ", ., square brackets,


# High Priority TO DO
#####################
# Make a large alert box appear when tests are complete.
# Make drives shows a status of "complete" if they have finished a test during the current run.
# Make the alarm beep repeat x number of times with a pause of m minutes.
# Find out why starting a test doesn't change the displayed drive status to "querying".
# Add a machine ID feature so you can number the machines and they'll have unique beep sequences.
# Make the Connection column show SATA vs IDE vs USB bridge (successful bridges, not thumb drives/bad enclosures).
# Make an ISO and add pcspkr to /etc/modules.
# Add support for having hdparm do secure wiping. This should skip the bus and run faster than DBAN but
#   make sure you DO NOT LET IT RUN OVER USB! Doing so can brick a drive apparently. More info here:
#        https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase
# Run the program with a variety of drives to make sure nothing crashes mdm.


# Moderate Priority To Do
#########################
# Make the program frequently (1hz) scan for changes in /dev/sdX to see if drives have been hot-swapped.
# Save status data to a /var/tmp file so that session settings remain if you quit the program and re-run it.
# Make F5 work for refresh also.
# Search for "SMART Self-test Log not supported" and differentiate reporting that from reporting a drive that
#   supports selt-test logging but no tests have ever been run on it.
# Rewrite the Drive.testHistory construction to use Drive.smartctlLines instead of Drive.smartctlOutput.
# Add functionality to extrapolate test completion within 1% (rather than 10%) based on smartctl reporting and time.
# Add shift-R refresh or some other trigger to rescan for Drives (in the event of hot-swapping).


# Low (long-term) Priority To Do
################################
# Rewrite the section of code that reads the attribute table. It's a pair of for-loops right now and clunky.
# Make the program detect if smartmontools is not installed so it can advise the user to install it.
# Make the program work under Windows and Mac OS.
# Turn the Drive class into a clean library suitable for general-purpose use and GPL release it.

import curses
import glob
import time
import os

from mdmSMART.Drive import *

# Drawing positions for view layout.
POS_BX = 1  # Left side of search/help bar.
POS_BY = 3  # Top side of search/help bar.
POS_MX = 1  # Left side of message bar.
POS_MY = 5  # Top side of message bar.
POS_DTX = 6  # Left side of drive table.
POS_DTY = 7  # Top side of drive table.

SELECTOR_ABSENT = -1
NO_KEYS_PRESSED = -1
ESCAPE_KEY = 27
ENTER_KEY = 10
RAPID_KEYPRESS_THRESHOLD = 30  # Minimum milliseconds to distinguish keyboard from barcode scanner.
SEARCH_PROMPT = "Find: "

# Constants related to the beep sequence alert.
BASE_BEEP = "beep -f1000 -l50 -n -f2000 -l50 -n -f3000 -l40 -n -f4000 -l30 -D1200"
BEEP_START_FREQ = 200
BEEP_FREQ_STEP = 100
BEEP_LENGTH_MS = 150
BEEP_DELAY_MS = 250

HOURS_WARNING = 30000  # Number of drive operation hours above which the user is warned of old age.
HOURS_CRITICAL = 50000  # Number of drive operation hours above which the user is warned of end-of-life imminence.

columnWidths = [8, 4, 5, 8, 24, 21, 7, 6, 5, 10, 15]

# Before initializing curses, remove the Esc key delay from the OS environment.
os.environ.setdefault('ESCDELAY', '0')

attributeHeader = "ID# ATTRIBUTE_NAME          FLAG     VALUE WORST THRESH TYPE      UPDATED  WHEN_FAILED RAW_VALUE"

# Check for root.
if not os.getuid() == 0:
    print("Only user ID #0 (root) can run this program")
    exit(1)


def main(screen):
    initCurses(screen)  # Set parameters of curses environment.
    screen.nodelay(True)  # Make getch() non-blocking.
    setupCursesUtils(screen)  # Connect curses to the utility function library.
    selector = SELECTOR_ABSENT  # Hide the drive selector until drives are found.
    searchString = ""
    searchModeFlag = False  # Toggle search mode (as versus command mode).
    barcodeScanDetection = False  # Treat rapid keypresses as barcode scans to be searched.
    redrawScreen = True  # Signal a screen redraw/refresh.
    refreshDevices = True  # Signal a rescan of all drives.
    autoRefresh = True  # Signal recurring rescan of all drives.
    autoRefreshDelaySecs = 60  # Time between auto-rescan of all drives.
    messageBarContents = ""
    programTitle = "%%%r%%%0Multi-Drive Manager"  # Title shown at top of screen.
    testInProgress = False  # True if any drive is in a testing state.
    completionAlert = False  # True if the program is alerting the user all drives have finished testing.
    abortionStartTime = time.time()  # Reset time marker of last abort command.

    # Build initial list of drives.
    devices = findAllDrives()

    exitFlag = False
    lastRefresh = time.time()
    while not exitFlag:
        # Check if auto-refresh should be triggered.
        if autoRefresh and (time.time() - lastRefresh) > autoRefreshDelaySecs:
            refreshDevices = True

        # Rescan the drives if signaled to.
        if refreshDevices:
            # Reset the signal flag.
            refreshDevices = False
            for device in devices:
                device.initiateQuery()
            lastRefresh = time.time()
            redrawScreen = True

        # Draw the screen if anything has changed.
        if redrawScreen:
            # Reset the signal flag.
            redrawScreen = False

            # Clear the screen
            screen.erase()
            screen.border(0)

            # Print the program title.
            printAt(1, 1, programTitle)

            # Print the search bar or help bar.
            if searchModeFlag:
                printAt(POS_BX, POS_BY, SEARCH_PROMPT + searchString)
            else:
                printAt(POS_BX, POS_BY, "(f)ind (r)efresh (s)hort test (l)ong test (L)ong test all (a)bort test (q)uit")

            # Print the message bar.
            printAt(POS_MX, POS_MY, messageBarContents)

            # Print the drive list.
            table = buildDriveTable(devices)  # Construct a table of attribute text from the drive list.
            if selector is not SELECTOR_ABSENT:
                table[selector+1][0] = CEC_REVERSE + table[selector+1][0]
            screenHeight, screenWidth = screen.getmaxyx()  # Get limitations of screen size.
            drawTable(table, columnWidths, POS_DTX, POS_DTY, screenWidth - POS_DTX, screenHeight - POS_DTY)

            # If a drive is currently selected.
            if selector is not SELECTOR_ABSENT:
                # Draw the selector.
                printAt(POS_DTX - 4, POS_DTY + selector + 1, CEC_REVERSE + "--> ")

                # Note the device the selector is pointed at.
                device = devices[selector]
                deviceName = device.devicePath  # Refer to the device by its path.

                # Print detailed info for the currently selected device starting from a position below the drive list.
                posX, posY = 1, POS_DTY + len(devices) + 2

                # Print the current smartctl testing status.
                if device.connector == "USB":
                    printAt(posX, posY, "SMART firmware was not reachable through USB interface.")
                else:
                    if device.smartStatusCode == SMART_STATUS_CODE_NOT_INITIALIZED:
                        smartTestStateMsg = SMART_STATUS_CODE_NOT_FOUND_MSG
                    else:
                        smartTestStateMsg = "SMART status code " + str(device.smartStatusCode) + ": "
                        smartTestStateMsg += device.smartStatusDescription
                    printAt(posX, posY, smartTestStateMsg)
                posY += 2  # Increment vertical cursor and add blank line.

                # Print the list of important attributes.
                if len(device.importantAttributes) > 0:
                    printAt(posX, posY, attributeHeader)
                    posY += 1
                    for attribute in device.importantAttributes:
                        printAt(posX, posY, attribute.smartctlLine)
                        posY += 1  # Increment vertical cursor
                    posY += 1  # Add a blank line before next section of info.

                # Print the test history for the device.
                # NOTE: The SMART firmware standard stores up to 21 tests and thereafter starts recording over top
                #       of older tests.
                if device.smartCapable:
                    if len(device.testHistory) > 0:
                        printAt(posX, posY, device.testHistoryHeader)
                        posY += 1  # Increment vertical cursor
                        for testResult in device.testHistory:
                            if any(msg in testResult for msg in harmlessTestMessages):
                                printAt(posX, posY, testResult)
                            else:
                                printAt(posX, posY, CEC_RED + testResult)
                            posY += 1  # Increment vertical cursor.
                    else:
                        printAt(posX, posY, "No history of SMART tests found for " + deviceName)
                        posY += 1  # Increment vertical cursor
                    posY += 1  # Add a blank line before next section of info.

            # Show the cursor when in search mode and hide it the rest of the time.
            if searchModeFlag:
                curses.curs_set(1)
                # Position the cursor by printing nothing where it should be.
                printAt(POS_BX, POS_BY + len(SEARCH_PROMPT + searchString), "")
            # Hide the cursor when not in search mode.
            else:
                curses.curs_set(0)

            # Overlay screen with alert notification if one is active.
            if completionAlert:
                printAt(20, 20, CEC_RED + CEC_REVERSE + "ALERT")  # DEBUG

            # Update the view.
            screen.refresh()

        # Check for and handle keypresses.
        keypress = screen.getch()
        if keypress is not NO_KEYS_PRESSED:
            # Assume the screen will need to be redrawn anytime a key is pressed.
            redrawScreen = True

            # Test for rapid keypresses if barcode scanner detection is enabled.
            if barcodeScanDetection:
                # Pause briefly to see if another keypress happens rapidly enough to imply barcode scanning.
                millisecondsElapsed = 0
                startTime = time.time()
                while millisecondsElapsed < RAPID_KEYPRESS_THRESHOLD:
                    # Repeatedly query getch().
                    keypress2 = screen.getch()
                    if keypress2 is not NO_KEYS_PRESSED:
                        searchModeFlag = True
                        searchString += curses.keyname(keypress)  # Add the first keypress to the search.
                        searchString += curses.keyname(keypress2)  # Add the second keypress to the search.
                        break
                    millisecondsElapsed = int((time.time() - startTime) * 1000)

            # If acknowledging an alert message.
            if completionAlert:
                completionAlert = False  # Shut off alert message.

            # In search mode most keys should be added to the search string until Esc or Enter are pressed.
            elif searchModeFlag:
                if keypress == ESCAPE_KEY:
                    searchString = ""
                    searchModeFlag = False
                elif keypress == ENTER_KEY:
                    if len(searchString) > 0:
                        selector, messageBarContents = searchDevices(searchString, devices)
                    searchModeFlag = False
                    searchString = ""  # Clear the search string after each search.
                elif keypress == curses.KEY_BACKSPACE:
                    searchString = searchString[:-1]
                elif keypress < 256:  # ASCII keys get added to search.
                    searchString += curses.keyname(keypress)
                else:
                    pass  # All other keys are ignored in search mode.

            # If not in any special modes (searching, alert acknowledgement, etc), then interpret keys as commands.
            else:
                # If a drive list is present then check for cursor keys.
                if len(devices) > 0:
                    if keypress == curses.KEY_DOWN:
                        selector = (selector + 1) % len(devices)
                    if keypress == curses.KEY_UP:
                        selector = (selector - 1) % len(devices)
                else:
                    selector = SELECTOR_ABSENT

                if keypress == ESCAPE_KEY:
                    selector = SELECTOR_ABSENT

                if keypress == ord('t'):  # DEBUG: For testing alerts.
                    completionAlert = True

                if keypress == ord('f'):
                    searchModeFlag = True

                if keypress == ord('s'):
                    if selector is not SELECTOR_ABSENT:
                        # Start the test, refresh the drive and redraw the screen.
                        devices[selector].runShortTest()
                        devices[selector].initiateQuery()
                        redrawScreen = True

                if keypress == ord('l'):
                    if selector is not SELECTOR_ABSENT:
                        # Start the test, refresh the drive and redraw the screen.
                        devices[selector].runLongTest()
                        devices[selector].initiateQuery()
                        redrawScreen = True

                if keypress == ord('L'):
                    if selector is not SELECTOR_ABSENT:
                        # Start the tests, refresh the drives and redraw the screen.
                        for device in devices:
                            if device.connector != "USB":
                                device.runLongTest()
                                device.initiateQuery()
                        redrawScreen = True

                if keypress == ord('a'):
                    if selector is not SELECTOR_ABSENT:
                        devices[selector].abortTest()
                        abortionStartTime = time.time()
                    refreshDevices = redrawScreen = True

                if keypress == ord('r'):
                    refreshDevices = redrawScreen = True

                if keypress in [ord('q'), ord('Q')]:
                    exitFlag = True

        # Check if any drives have a smartctl query in progress.
        for device in devices:
            if device.state == DR_STATE_QUERYING and device.queryIsDone():
                # If a query just completed then process the smartctl output.
                device.interpretSmartctlOutput()
                # If at least one test was in progress then check if all tests have completed.
                if testInProgress:
                    secondsSinceLastAbortCommand = int((time.time() - abortionStartTime))
                    if allDrivesAreIdleOrUnknown(devices) and secondsSinceLastAbortCommand > 5:
                        testInProgress = False
                        completionAlert = True
                        # Send alert beep with non-blocking terminal command.
                        beepCommand = BASE_BEEP
                        subprocess.Popen(beepCommand.split(), stdout=subprocess.PIPE, stderr=DEVNULL)
                else:
                    if any(drive.state == DR_STATE_TESTING for drive in devices):
                        testInProgress = True

                redrawScreen = True  # Show outcome by redrawing screen.

        time.sleep(0.01)  # Sleep for this many seconds to reduce CPU load.

    # Clear the screen so that curses doesn't leave it's junk on the terminal (only happens on sysrescue machine).
    screen.clear()
    screen.refresh()


# Construct a 2D array for drive data, including a header row.
def buildDriveTable(driveList):
    table = list()
    table.append(["Path", "Conn", "RPM", "Size", "Model", "Serial", "ReAlloc", "Hours", "GSen", "Alert", "State"])
    for drive in driveList:
        # Make a color-coded string of the reallocated sector count.
        if drive.reallocCount is 0:
            reallocText = CEC_GREEN + "0"
        elif drive.reallocCount > 0:
            reallocText = CEC_RED + str(drive.reallocCount)
        else:
            reallocText = CEC_YELLOW + "???"  # Includes NOT_INITIALIZED.

        # Note whether the device has any failed attributes.
        if drive.hasFailureHistory():
            alertMessage = CEC_RED + "bad test"
        elif drive.hasFailedAttributes():
            alertMessage = CEC_YELLOW + "bad value"
        else:
            alertMessage = ""

        # Check whether hours of operation was detected.
        if drive.hours is NOT_INITIALIZED:
            driveHours = ""
        elif drive.hours > HOURS_CRITICAL:
            driveHours = CEC_RED + str(drive.hours)
        elif drive.hours > HOURS_WARNING:
            driveHours = CEC_YELLOW + str(drive.hours)
        else:
            driveHours = str(drive.hours)

        entry = list()
        entry.append(drive.devicePath)
        entry.append(drive.connector)
        entry.append(drive.rotationRate)
        entry.append(drive.capacity)
        entry.append(drive.model)
        entry.append(drive.serial)
        entry.append(reallocText)
        entry.append(driveHours)
        entry.append(str(drive.GSenseCount))
        entry.append(alertMessage)
        entry.append(drive.statusString())

        table.append(entry)
    return table


# Returns true if all drives are idle/unknown,  (not testing or querying).
def allDrivesAreIdleOrUnknown(driveList):
    for drive in driveList:
        if drive.state not in [DR_STATE_UNKNOWN, DR_STATE_IDLE]:
            return False
    return True


# Initialize Curses (set various parameters, etc).
def initCurses(screen):
    screen.nodelay(True)  # Make getch() non-blocking.


def searchDevices(searchString, devices):
    message = ""  # Default to no message.
    selector = SELECTOR_ABSENT  # Default to hiding the selector.
    # Build a list of search-matching devices and highlight them as selected.
    matchingDevices = list()
    for i in range(len(devices)):
        if devices[i].matchSearchString(searchString):
            matchingDevices.append(devices[i])
            selector = i  # Set selector to matching drive.
    if len(matchingDevices) == 0:
        message = "No drives matched search string: " + searchString
    if len(matchingDevices) >= 2:
        message = "Search matched multiple drives:"
        for device in matchingDevices:
            message += " " + device.devicePath
            selector = SELECTOR_ABSENT  # Hide the selector if >1 device matched search.
    return selector, message


def findAllDrives():
    # Get a list of all hard drive device paths.
    devicePaths = glob.glob('/dev/sd?')

    devices = list()

    # Load each device and print a summary of it.
    for devicePath in sorted(devicePaths):
        # Attempt to load device smartctl info.
        device = Drive(devicePath)
        devices.append(device)

    return devices


curses.wrapper(main)
