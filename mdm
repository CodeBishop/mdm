#!/usr/bin/env python2

# Multi-Drive Manager (mdm)
###########################
# A utility for managing the simultaneous S.M.A.R.T. testing and secure wiping of multiple data storage devices.

# Misc Notes
############
# Summary of sysrescue display differences.
#   The terminal does not get restored when a curses program ends. The prompt re-appears at the bottom
#       and the screen remains cluttered with whatever was on display.
#   Only 8 colors are available and the curses.COLORS constant reflects that fact.
#   Font effects: dim=underline=normal, reverse=standout(fg/bg color reversal), bold is brighter text.
#       blink is grey text on dark grey background (no blinking).
#   Characters known to appear in smartctl output:
#       Parantheses, numbers, letters, underscores, whitespace, +, -, :, =, ", ., square brackets,


# High Priority TO DO
#####################
# Remove the gsense column but add gsense to the list of important attributes.
# Eliminate the use of Drive.oneLineSummary() from mdm because it doesn't allow for embedded color-highlighting
#   and Drive shouldn't really be responsible for any form of screen rendering anyways.
#       Then decruft: Move the column width constants out of Drive.py and delete Drive.oneLineSummary()
# Flag past failed scans in the columns somewhere. Maybe replace the WHEN_FAIL column with a general purpose
#   "alert" column.
# Add support for having hdparm do secure wiping. This should skip the bus and run faster than DBAN but
#   make sure you DO NOT LET IT RUN OVER USB! Doing so can brick a drive apparently. More info here:
#        https://ata.wiki.kernel.org/index.php/ATA_Secure_Erase
# Figure out why there's a blank line after the test history header. Is the first item in the list blank?
# See if there's a quick way to make the program reverse color text on devices that just finished a test.
# The rapid keypress detector can be triggered by pressing keys during a refresh. Fix that.
# Highlight drives that have completed and color them depending on whether they're good or bad.
# Investigate whether you can save temporary files anywhere in order to track things like whether a currently
#   running test is a short or long test. If not then remove the short and long test states from Drive.
# Make drives blink when they're done and the whole screen blink if all drives are done.


# Moderate Priority To Do
#########################
# Add a gsense column.
# Make F5 work for refresh also.
# Search for "SMART Self-test Log not supported" and differentiate reporting that from reporting a drive that
#   supports selt-test logging but no tests have ever been run on it.
# See if StorageDevice.smartctlLines can simplify some of the stuff you're doing with StorageDevice.smartctlOutput.
# Highlight drives that have completed a test.
# Try to find some way to make the system beep. Printing "\a" and "\007" didn't work.
# Add a test that if the number of hours is less than a 1000 then the program warns you that smartctl may be
#   misinterpreting minutes into hours when hours was what the manufacturer actually meant.
# Make shift+s be a way to order all idle drives to short-test themselves. Same for long tests.
# Make it beep when a drive completes a scan and triple beep when all drives become idle.
#   Maybe even make it triple-beep on a decreasing time-scale (up to 3 times?) and show a flashing message window.
# Add functionality to extrapolate test completion within 1% (rather than 10%) based on smartctl reporting and time.
# Test that the (r)efresh command relocates the selector properly if devices are hot-unplugged.
# Add an RPM column that eliminates the type column as an ssd/hdd divider (and also provides more info).
# Add the ability to abort a test-in-progress.
# Show number of hours.
#   The smartmontools FAQ https://www.smartmontools.org/wiki/FAQ says:
#       Some Maxtor's record attribute #9 in minutes not hours (correctable by '-v 9,minutes').
#       Some Fujitsu's record attribute #9 in seconds not hours (correctable by '-v 9,seconds').
#   Look for discrepancies in drive hours. Isn't there a bunch of ridiculously low-hour Fujitsu's? Do their logged
#       tests show different hours from their attribute #9?
#   Check if drives' hours in the test logs and attribute #9 are consistent.

# Low (long-term) Priority To Do
################################
# Rewrite the section of code that reads the attribute table. It's a pair of for-loops right now and clunky.
# Make the program detect if smartmontools is not installed so it can advise the user to install it.
# Make the program work under Windows and Mac OS.
# Turn the StorageDevice class into a clean library suitable for general-purpose use and GPL release it.

import curses
import glob
import time
import os

from mdmSMART.Drive import *

# Drawing positions for view layout.
POS_BX = 1  # Left side of search/help bar.
POS_BY = 3  # Top side of search/help bar.
POS_MX = 1  # Left side of message bar.
POS_MY = 5  # Top side of message bar.
POS_DLX = 8  # Left side of drive list.
POS_DLY = 8  # Top side of drive list.

SELECTOR_ABSENT = -1
NO_KEYS_PRESSED = -1
ESCAPE_KEY = 27
ENTER_KEY = 10
RAPID_KEYPRESS_THRESHOLD = 30  # Minimum milliseconds to distinguish keyboard from barcode scanner.
SEARCH_PROMPT = "Find: "

columnWidths = [8, 4, 4, 8, 24, 21, 7, 6, 5, 10, 15]

# Before initializing curses, remove the Esc key delay from the OS environment.
os.environ.setdefault('ESCDELAY', '0')

# Check for root.
if not os.getuid() == 0:
    print("Only user ID #0 (root) can run this program")
    exit(1)


def main(screen):
    initCurses(screen)  # Set parameters of curses environment.
    screen.nodelay(True)  # Make getch() non-blocking.
    setupCursesUtils(screen)  # Connect curses to the utility function library.
    selector = SELECTOR_ABSENT  # Hide the drive selector until drives are found.
    searchString = ""
    searchModeFlag = False  # Toggle search mode (as versus command mode).
    barcodeScanDetection = False  # Treat rapid keypresses as barcode scans to be searched.
    redrawScreen = True  # Signal a screen redraw/refresh.
    refreshDevices = True  # Signal a rescan of all drives.
    autoRefresh = True  # Signal recurring rescan of all drives.
    autoRefreshDelaySecs = 60  # Time between auto-rescan of all drives.
    messageBarContents = ""

    # Build initial list of drives.
    devices = findAllDrives()

    exitFlag = False
    lastRefresh = time.time()
    while not exitFlag:
        # Check if auto-refresh should be triggered.
        if autoRefresh and (time.time() - lastRefresh) > autoRefreshDelaySecs:
            refreshDevices = True

        # Rescan the drives if signaled to.
        if refreshDevices:
            # Reset the signal flag.
            refreshDevices = False
            for device in devices:
                device.initiateQuery()
            lastRefresh = time.time()
            redrawScreen = True

        # Draw the screen if anything has changed.
        if redrawScreen:
            # Reset the signal flag.
            redrawScreen = False

            # Clear the screen
            screen.erase()
            screen.border(0)

            # Print the program title.
            printAt(1, 1, "%%%rMulti-Drive Manager")

            # Print the search bar or help bar.
            if searchModeFlag:
                printAt(POS_BX, POS_BY, SEARCH_PROMPT + searchString)
            else:
                printAt(POS_BX, POS_BY, "(f)ind (r)efresh (s)hort test (l)ong test (L)ong test all (a)bort test (q)uit")

            # Print the message bar.
            screen.addstr(POS_MY, POS_MX, messageBarContents)

            # Print the drive list.
            screen.addstr(POS_DLY - 1, POS_DLX, summaryHeader())
            for y in range(len(devices)):
                screen.addstr(POS_DLY + y, POS_DLX, devices[y].oneLineSummary())

            # If a drive is currently selected.
            if selector is not SELECTOR_ABSENT:
                # Draw the selector.
                screen.addstr(POS_DLY + selector, POS_DLX - 4, "-->")

                # Note the device the selector is pointed at.
                device = devices[selector]
                deviceName = device.devicePath  # Refer to the device by its path.

                # Print detailed info for the currently selected device starting from a position below the drive list.
                posX, posY = 1, POS_DLY + len(devices) + 1

                # Print the current smartctl testing status.
                if device.connector == "USB":
                    screen.addstr(posY, posX, "SMART firmware was not reachable through USB interface.")
                else:
                    if device.smartStatusCode == SMART_STATUS_CODE_NOT_INITIALIZED:
                        smartTestStateMsg = SMART_STATUS_CODE_NOT_FOUND_MSG
                    else:
                        smartTestStateMsg = "SMART status code " + str(device.smartStatusCode) + ": "
                        smartTestStateMsg += device.smartStatusDescription
                    screen.addstr(posY, posX, smartTestStateMsg)
                posY += 2  # Increment vertical cursor and add blank line.

                # Print the list of important attributes.
                if len(device.importantAttributes) > 0:
                    screen.addstr(posY, posX, attributeHeader())
                    posY += 1
                    for attribute in device.importantAttributes:
                        screen.addstr(posY, posX, attribute.smartctlLine)
                        posY += 1  # Increment vertical cursor
                    posY += 1  # Add a blank line before next section of info.

                # Print the test history for the device.
                # NOTE: The SMART firmware standard stores up to 21 tests and thereafter starts recording over top
                #       of older tests.
                if len(device.testHistory) > 0:
                    screen.addstr(posY, posX, device.testHistoryHeader)
                    posY += 1  # Increment vertical cursor
                    for testResult in device.testHistory:
                        screen.addstr(posY + 1, posX, testResult)
                        posY += 1  # Increment vertical cursor.
                else:
                    screen.addstr(posY, posX, "No history of SMART tests found for " + deviceName)
                    posY += 1  # Increment vertical cursor
                posY += 1  # Add a blank line before next section of info.

            # Show the cursor when in search mode and hide it the rest of the time.
            if searchModeFlag:
                curses.curs_set(1)
                # Position the cursor by printing nothing where it should be.
                screen.addstr(POS_BY, POS_BX + len(SEARCH_PROMPT + searchString), "")

            # Hide the cursor when not in search mode.
            else:
                curses.curs_set(0)

            # Update the view.
            screen.refresh()

        # Check for and handle keypresses.
        keypress = screen.getch()
        if keypress is not NO_KEYS_PRESSED:
            # Assume the screen will need to be redrawn anytime a key is pressed.
            redrawScreen = True

            # Test for rapid keypresses if barcode scanner detection is enabled.
            if barcodeScanDetection:
                # Pause briefly to see if another keypress happens rapidly enough to imply barcode scanning.
                millisecondsElapsed = 0
                startTime = time.time()
                while millisecondsElapsed < RAPID_KEYPRESS_THRESHOLD:
                    # Repeatedly query getch().
                    keypress2 = screen.getch()
                    if keypress2 is not NO_KEYS_PRESSED:
                        searchModeFlag = True
                        searchString += curses.keyname(keypress)  # Add the first keypress to the search.
                        searchString += curses.keyname(keypress2)  # Add the second keypress to the search.
                        break
                    millisecondsElapsed = int((time.time() - startTime) * 1000)

            # In search mode most keys should be added to the search string until Esc or Enter are pressed.
            if searchModeFlag:
                if keypress == ESCAPE_KEY:
                    searchString = ""
                    searchModeFlag = False
                elif keypress == ENTER_KEY:
                    if len(searchString) > 0:
                        selector, messageBarContents = searchDevices(searchString, devices)
                    searchModeFlag = False
                    searchString = ""  # Clear the search string after each search.
                elif keypress == curses.KEY_BACKSPACE:
                    searchString = searchString[:-1]
                elif keypress < 256:  # ASCII keys get added to search.
                    searchString += curses.keyname(keypress)
                else:
                    pass  # All other keys are ignored in search mode.

            # When not in search mode, all keys are interpreted as commands.
            else:
                # If a drive list is present then check for cursor keys.
                if len(devices) > 0:
                    if keypress == curses.KEY_DOWN:
                        selector = (selector + 1) % len(devices)
                    if keypress == curses.KEY_UP:
                        selector = (selector - 1) % len(devices)
                else:
                    selector = SELECTOR_ABSENT

                if keypress == ESCAPE_KEY:
                    selector = SELECTOR_ABSENT

                if keypress == ord('f'):
                    searchModeFlag = True

                if keypress == ord('s'):
                    if selector is not SELECTOR_ABSENT:
                        # Start the test, refresh the drive and redraw the screen.
                        devices[selector].runShortTest()
                        devices[selector].initiateQuery()# = Drive(devices[selector].devicePath)
                        redrawScreen = True

                if keypress == ord('l'):
                    if selector is not SELECTOR_ABSENT:
                        # Start the test, refresh the drive and redraw the screen.
                        devices[selector].runLongTest()
                        devices[selector].initiateQuery()# = Drive(devices[selector].devicePath)
                        redrawScreen = True

                if keypress == ord('L'):
                    if selector is not SELECTOR_ABSENT:
                        # Start the tests, refresh the drives and redraw the screen.
                        for device in devices:
                            if device.connector != "USB":
                                device.runLongTest()
                                device.initiateQuery()
                        redrawScreen = True

                if keypress == ord('a'):
                    if selector is not SELECTOR_ABSENT:
                        devices[selector].abortTest()
                    refreshDevices = redrawScreen = True

                if keypress == ord('r'):
                    refreshDevices = redrawScreen = True

                if keypress == ord('q'):
                    exitFlag = True

        # Check if any drives have a smartctl query in progress.
        for device in devices:
            if device.state == DR_STATE_QUERYING and device.queryIsDone():
                device.interpretSmartctlOutput()  # Process smartctl output.
                redrawScreen = True  # Show outcome by redrawing screen.

        time.sleep(0.01)  # Sleep for this many seconds to reduce CPU load.

    # Clear the screen so that curses doesn't leave it's junk on the terminal (only happens on sysrescue machine).
    screen.clear()
    screen.refresh()


def buildDriveTable(driveList):
    # This method fully understand what Drives are. It's tightly coupled to that class.
    # It does not know the column widths, it just creates a 2-D array of ColoredString objects.
    # Inserts color coding into the strings based on value tolerances.
    # Determines the column ordering and which columns exist.
    # Writes the columns header.
    table = list()
    table.append(["Path", "Conn", "Type", "Size", "Model", "Serial", "ReAlloc", "Hours", "GSen", "WHENFAIL", "State"])
    for drive in driveList:
        # Make a color-coded string of the reallocated sector count.
        if drive.reallocCount > 0:
            reallocText = CEC_RED + str(drive.reallocCount)
        elif self.reallocCount < 0:
            reallocText = leftColumn("???", CW_REALLOC)
        else:
            reallocText = leftColumn(str(self.reallocCount), CW_REALLOC)

        entry = list()
        entry.append(drive.devicePath)
        entry.append(drive.connector)
        entry.append(drive.driveType)
        entry.append(drive.capacity)
        entry.append(drive.model)
        entry.eppend(drive.serial)
        description += reallocText
        description += leftColumn(str(self.hours), CW_HOURS)
        description += leftColumn(str(self.GSenseCount), CW_GSENSE)
        description += whenFailedStatus
        stateDesc = DR_STATE_MSG[self.state]


# Initialize Curses (set various parameters, etc).
def initCurses(screen):
    screen.nodelay(True)  # Make getch() non-blocking.


def searchDevices(searchString, devices):
    message = ""  # Default to no message.
    selector = SELECTOR_ABSENT  # Default to hiding the selector.
    # Build a list of search-matching devices and highlight them as selected.
    matchingDevices = list()
    for i in range(len(devices)):
        if devices[i].matchSearchString(searchString):
            matchingDevices.append(devices[i])
            selector = i  # Set selector to matching drive.
    if len(matchingDevices) == 0:
        message = "No drives matched search string: " + searchString
    if len(matchingDevices) >= 2:
        message = "Search matched multiple drives:"
        for device in matchingDevices:
            message += " " + device.devicePath
            selector = SELECTOR_ABSENT  # Hide the selector if >1 device matched search.
    return selector, message


def findAllDrives():
    # Get a list of all hard drive device paths.
    devicePaths = glob.glob('/dev/sd?')

    devices = list()

    # Load each device and print a summary of it.
    for devicePath in sorted(devicePaths):
        # Attempt to load device smartctl info.
        device = Drive(devicePath)
        devices.append(device)

    return devices


curses.wrapper(main)
