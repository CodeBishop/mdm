




Potential Commands
------------------
    One drive short scan.
    One drive long scan.
    One drive wipe.
    One drive long scan and if pass then wipe.
    One drive show all test history or state there is none or state that the drive is incapable.
    All drives short scan.
    All drives long scan.
    All drives wipe.
    All drives long scan and if pass then wipe.


Having an ETA Column
--------------------
    Take the estimated completion time from the terminal output of starting a smartctl test.
    Subtract that date object from the current date object to get an ETA.
    Save the ETA to a /var/tmp file filed by serial number. If the drive has no serial number then don't save.
    After each drive.interpretSmartctlOutput() call the drive should be asked if it's currently running a test and has a
        serial number. If so then call Drive.readETAFile()


Having an ETA Column Alternative: Drive-centric Approach
--------------------------------------------------------
    The main program calls a static method of Drive to set the class variable of the ETA file path.
    When Drive.interpretSmartctlOutput() is called the Drive checks if there's an ETA file and the Drive is testing
        and the drive has no ETA and the drive has a serial number. Then it should look for itself in the ETA file
        and load its ETA if found.
    When Drive.startTest() is called it feeds the terminal output to Drive.interpretTestCommand(). This function
        checks if there's an ETA file


Things That Should Be Possible When Drawing the Drive Table
-----------------------------------------------------------
    Re-arrange the column ordering.
    Set individual column widths.
    Turn columns off or on.
    Move the top-left corner position.
    Specify a box (max width and height) that it won't overflow.
    Make it scrollable?

Redoing Drive Table Drawing
---------------------------
buildDriveTable()
    This method fully understand what Drives are. It's tightly coupled to that class.
    It does not know the column widths, it just creates a 2-D array of ColoredString objects.
    Inserts color coding into the strings based on value tolerances.
    Determines the column ordering and which columns exist.
    Writes the columns header.
drawTable(String table[][], columnWidths, x, y, width, height)
    Knows nothing about Drives.
    Draws strings at screen positions based on TableLayout description.
    Truncates strings to the column widths specified in TableLayout and adds an ellipsis if needed.
    Understands color codes and uses them when making its curses.putStr() calls.
    Truncates strings and table rows to fit within the given width and height restrictions.
    Should probably draw to a curses.Pad and then paste the pad onto the screen.
ColoredString
    length(): Returns the length of the string, not including color codes.
    subset(start, end): Returns a section of a string, including color codes but indexed without them.
drawColoredString(x, y, string)
    Draws a color-coded string at a given location.
TableLayout
    Has column widths but no understanding of what's in those columns.
    Has no connection to the Drive class.
