




Potential Commands
------------------
    One drive short scan.
    One drive long scan.
    One drive wipe.
    One drive long scan and if pass then wipe.
    One drive show all test history or state there is none or state that the drive is incapable.
    All drives short scan.
    All drives long scan.
    All drives wipe.
    All drives long scan and if pass then wipe.


Having an ETA Column
--------------------
    Take the estimated completion time from the terminal output of starting a smartctl test.
    Subtract that date object from the current date object to get an ETA.
    Save the ETA to a /var/tmp file filed by serial number. If the drive has no serial number then don't save.
    After each drive.interpretSmartctlOutput() call the drive should be asked if it's currently running a test and has a
        serial number. If so then call Drive.readETAFile()


Having an ETA Column Alternative: Drive-centric Approach
--------------------------------------------------------
    The main program calls a static method of Drive to set the class variable of the ETA file path.
    Add a Drive.completionPercentage member to the class definition. It gets loaded from the ETA file and also
        re-derived at each interpretSmartCtlOutput() call which also checks if the percentage has changed in the
        wrong direction. In that event the Drive disables its ETA member on the assumption that something has gone
        screwy with the progress measurement. This will catch instances where a new smart test has been ordered
        from the command line while mdm still thought there was a previous one running based on the ETA file. If the
        percentage has changed in the right direction then the drive updates the ETA file. This will provide the
        initial save also.
    When Drive.startTest() is called it feeds the terminal output to Drive.interpretTestCommand(). This function
        checks if there's an ETA file and if so then it puts this Drive's info into the ETA file.


Things That Should Be Possible When Drawing the Drive Table
-----------------------------------------------------------
    Re-arrange the column ordering.
    Set individual column widths.
    Turn columns off or on.
    Move the top-left corner position.
    Specify a box (max width and height) that it won't overflow.
    Make it scrollable?

Redoing Drive Table Drawing
---------------------------
buildDriveTable()
    This method fully understand what Drives are. It's tightly coupled to that class.
    It does not know the column widths, it just creates a 2-D array of ColoredString objects.
    Inserts color coding into the strings based on value tolerances.
    Determines the column ordering and which columns exist.
    Writes the columns header.
drawTable(String table[][], columnWidths, x, y, width, height)
    Knows nothing about Drives.
    Draws strings at screen positions based on TableLayout description.
    Truncates strings to the column widths specified in TableLayout and adds an ellipsis if needed.
    Understands color codes and uses them when making its curses.putStr() calls.
    Truncates strings and table rows to fit within the given width and height restrictions.
    Should probably draw to a curses.Pad and then paste the pad onto the screen.
ColoredString
    length(): Returns the length of the string, not including color codes.
    subset(start, end): Returns a section of a string, including color codes but indexed without them.
drawColoredString(x, y, string)
    Draws a color-coded string at a given location.
TableLayout
    Has column widths but no understanding of what's in those columns.
    Has no connection to the Drive class.
